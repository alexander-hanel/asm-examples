# AES 

The goal of this repository is to aid in understanding how the Advanced Encryption Standard looks when compiled in C or C++. This repository contains compiled executable files, their corresponding PDB files and a link to the original source code.  It is recommend to download all files, open up the executable in IDA, load the PDB file and then compare the source code. For individuals not familiar with AES, I would recommend checking out the references.  

## References 

[A Stick Figure Guide to the Advanced Encryption Standard (AES)](http://www.moserware.com/2009/09/stick-figure-guide-to-advanced.html)

 - Simple introduction 

[Advanced Encryption Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) (Wikipedia) 
 
 - Expands on the stick figure explanation 
 
[NIST AES](http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf)  

[A Specification for Rijndael, the AES Algorithm](http://techheap.packetizer.com/cryptography/encryption/spec.v36.pdf)
[AES Encryption Videos](https://www.youtube.com/playlist?list=PLKK11LigqitiRH57AbtyJyzsfbNfA8nb-) by [What's a Creel?](https://www.youtube.com/user/WhatsACreel/featured)
 
 - Creating AES from scratch in C++ 
 - Note: [Video 5](https://www.youtube.com/watch?v=4pmR49izUL0) is missing from the playlist.

[Purdue AES Lecture Notes](https://engineering.purdue.edu/kak/compsec/NewLectures/Lecture8.pdf)
 
 - Example code in Python 


## Notes

`In progress, nothing original`

High-level description - [Via Wikipedia](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard#High-level_description_of_the_algorithm) 

1. Key Expansion 
2. Initial Round (AddRoundKey)
3. Rounds (SubBytes, ShitRows, MixColumns & AddRoundKeys)
4. Final Round (SubBytes, ShiftRows and AddRoundKeys)


A typical AES function would have a function flow as seen below. This can vary but knowing the function flow can be useful for quickly identifying the functions without understanding the core logic. 
```
AES()
{
	Key_Expansion(key)
	while(n)
		Add_Round_Key()
		Sub_Bytes()
		Shift_Rows()
		Mix_Columns() 

		Add_Rounds()
		Sub_Bytes()
		Shift_Rows()

	return 
}
```

#### Key Expansion 
The key are used by the key expansion to generate a set of Round keys. Round keys are derived from the cipher key using [Rijndael's key schedule](https://en.wikipedia.org/wiki/Rijndael_key_schedule). AES requires a separate 128-bit round key block for each round plus one more. The [keys schedule](https://en.wikipedia.org/wiki/Key_schedule) is used to expand a short key into a number of seperate round keys. It produces the needed round keys from the initial key. The key schedule utilizes a number of operations such as Rotate, Rcon and S-Box. Identifying the expanded key size can be used to identify the size of the key. For example, 128 bit-key uses a key expansion array of 176 bytes, 192 bit-key uses a key expansion array of 208 bytes and 256 bit-key uses a key expansion array of 240 bytes [source](https://www.samiam.org/key-schedule.html). From a reversing perspective, identifying the key expansion function can be used to identify the original key because it is first N bytes of the expanded key. To identify this function search for code cross-references to the S-box or Rcon bytes. 

Pseudo Code 
```
KeyExpansion(byte key[4*Nk], word k[Nn+1,Nc], Nc, Nk, Nn)
begin
 i = 0
 while (i < Nk)
    k[i] = word [ key[4*i+3], key[4*i+2], key[4*i+1], key[4*i] ]
    i = i + 1
 end while

 i = Nk
 while (i < Nc * (Nn + 1))
    word temp = k[i - 1]

   if (i mod Nk = 0)
      temp = SubWord(RotWord(temp)) xor Rcon[i / Nk]
   else if ((Nk > 6) and (i mod Nk = 4))
      temp = SubWord(temp)
   end if

   k[i] = k[i - Nk] xor temp
   i = i + 1
 end while
end 
```


##### Rotate
The rotate operations takes a `32 bit word (dword)` and rotates it eight bits to the left such that the high eight bits "wrap around" and become the low eight bits of the result. 

##### Rcon 
Rcon is what the Rijndael documentation calls the exponentiation of 2 to a user-specified value. Note that this operation is not performed with regular integers, but in Rijndael's finite field. Only the first some of these constants are actually used – up to rcon[10] for AES-128 (as 11 round keys are needed). Rcon[0] is not used in AES algorithm. The Rijndael variants with larger block sizes use more of these constants, up to rcon[29] for Rijndael with 128-bit keys and 256 bit blocks (needs 15 round keys of each 256 bit, which means 30 full rounds of key expansion, which means 29 calls to the key schedule core using the round constants). The Rcon contains cross references to the key expansion function. 

##### S-box (also known as Rijndael S-box)
The [Rijndael S-box](https://en.wikipedia.org/wiki/Rijndael_S-box) is a `256` byte matrix (square array of numbers). The S-box (substitution box) serves as a lookup table. The S-box is generated by determining the multiplicative inverse for a given number in Rijndael's finite field (also known as Galois field). The multiplcative inverse of two numbers, means the reciprocal (1/number) multiply together to make 1. For example, 1 and -1 are their own reciprocals because 1 × 1 = 1 and -1 × -1 = 1. The S-box contains cross references to the key expansion function and the Sub-Byte

Useful read: [The Laws of Cryptography Advanced Encryption Standard: S-Boxes](http://www.cs.utsa.edu/~wagner/laws/SBoxes.html)


###### IDAPython constant search
```python
sbox = "63 7C 77 7B F2 6B 6F C5 30 01 67 2B"
rcon = "8D 01 02 04 08 10 20 40 80 1B 36"
addr = idc.get_inf_attr(INF_MIN_EA)
addr = idc.find_binary(addr, SEARCH_DOWN, sbox) 
if addr != idc.BADADDR:
  print ("RCON located at 0x%x" % addr)
   
addr = idc.find_binary(addr, SEARCH_DOWN, rcon) 
if addr != idc.BADADDR:
   print ("SBOX located at 0x%x" % addr)
```


##### AddRounds
Simple XOR loop. The XOR loop is sometimes inline in the main AES function or could be its own function. 

Pseudo Code 
```
XorRoundKey(byte state[4,Nc], word k[round,-], Nc)
Begin
for c = 0 step 1 to Nc – 1
  for r = 0 step 1 to 3
    state[r,c] = state[r,c] xor xbyte(r, k[round,c])
  end for
 end for
end 
```

##### SubBytes
Non-linear byte-by-byte substitution function that uses the S-box as a 16 by 16 lookup table to produce a new byte value. 

Pseudo Code 
```
SubBytes(byte state[4,Nc], Nc)
begin
 for r = 0 step 1 to 3
    for c = 0 step 1 to Nc - 1
      state[r,c] = Sbox[state[r,c]]
    end for
 end for
end
```

Assembly Example 
```
.text:0040111D aes_subbytes proc near                 
.text:0040111D                                        
.text:0040111D         push    esi
.text:0040111E         push    edi
.text:0040111F         push    4
.text:00401121         pop     edi
.text:00401122
.text:00401122 loc_401122:                             
.text:00401122         push    4
.text:00401124         mov     eax, ecx
.text:00401126         pop     esi
.text:00401127
.text:00401127 loc_401127:                            
.text:00401127         movzx   edx, byte ptr [eax]
.text:0040112A         mov     dl, ds:Sbox[edx]
.text:00401130         mov     [eax], dl
.text:00401132         add     eax, 4
.text:00401135         dec     esi
.text:00401136         jnz     short loc_401127
.text:00401138         inc     ecx
.text:00401139         dec     edi
.text:0040113A         jnz     short loc_401122
.text:0040113C         pop     edi
.text:0040113D         pop     esi
.text:0040113E         retn
.text:0040113E aes_subbytes endp
```

Links
 - [The Laws of Cryptography: Advanced Encryption Standard: S-Boxes](http://www.cs.utsa.edu/~wagner/laws/SBoxes.html)

##### ShitRows
For shifting the rows of the state array. 

Pseudo Code 
```
ShiftRows(byte state[4,Nc], Nc)
begin
 byte t[Nc]
 for r = 1 step 1 to 3
   for c = 0 step 1 to Nc - 1
      t[c] = state[r, (c + h(r,Nc)) mod Nc]
   end for
   for c = 0 step 1 to Nc – 1
      state[r,c] = t[c]
   end for
 end for
end 
```

Assembly Example 
```
.text:0040113F aes_shiftrows? proc near                
.text:0040113F                                        
.text:0040113F         mov     dl, [eax+5]
.text:00401142         mov     cl, [eax+1]
.text:00401145         mov     [eax+1], dl
.text:00401148         mov     dl, [eax+9]
.text:0040114B         mov     [eax+5], dl
.text:0040114E         mov     dl, [eax+0Dh]
.text:00401151         mov     [eax+9], dl
.text:00401154         mov     dl, [eax+0Ah]
.text:00401157         mov     [eax+0Dh], cl
.text:0040115A         mov     cl, [eax+2]
.text:0040115D         mov     [eax+2], dl
.text:00401160         mov     dl, [eax+0Eh]
.text:00401163         mov     [eax+0Ah], cl
.text:00401166         mov     cl, [eax+6]
.text:00401169         mov     [eax+6], dl
.text:0040116C         mov     dl, [eax+0Fh]
.text:0040116F         mov     [eax+0Eh], cl
.text:00401172         mov     cl, [eax+3]
.text:00401175         mov     [eax+3], dl
.text:00401178         mov     dl, [eax+0Bh]
.text:0040117B         mov     [eax+0Fh], dl
.text:0040117E         mov     dl, [eax+7]
.text:00401181         mov     [eax+0Bh], dl
.text:00401184         mov     [eax+7], cl
.text:00401187         retn
.text:00401187 aes_shiftrows? endp
```


##### MixColumns
For mixing up of the bytes in each column separately. 

Pseudo Code 
```
MixColumns(byte state[4,Nc], Nc)
begin
 byte t[4]
 for c = 0 step 1 to Nc – 1
   for r = 0 step 1 to 3
      t[r] = state[r,c]
   end for
   for r = 0 step 1 to 3
      state[r,c] = FFmul(0x02, t[r]) xor 
      FFmul(0x03, t[(r + 1) mod 4]) xor
      t[(r + 2) mod 4] xor t[(r + 3) mod 4]
   end for
 end 
 ```
Assembly Example 
```
.text:00401188 aes_mix_columns proc near               
.text:00401188
.text:00401188 var_3   = byte ptr -3
.text:00401188 var_2   = byte ptr -2
.text:00401188 var_1   = byte ptr -1
.text:00401188
.text:00401188         push    ebp
.text:00401189         mov     ebp, esp
.text:0040118B         push    ecx
.text:0040118C         push    ebx
.text:0040118D         push    esi
.text:0040118E         push    4
.text:00401190         add     ecx, 2
.text:00401193         pop     esi
.text:00401194
.text:00401194 loc_401194:                             
.text:00401194         mov     al, [ecx+1]
.text:00401197         xor     al, [ecx]
.text:00401199         mov     dl, [ecx-2]
.text:0040119C         mov     bl, [ecx-1]
.text:0040119F         mov     [ebp+var_3], al
.text:004011A2         xor     al, dl
.text:004011A4         xor     al, bl
.text:004011A6         mov     [ebp+var_1], al
.text:004011A9         mov     [ebp+var_2], dl
.text:004011AC         xor     dl, bl
.text:004011AE         mov     al, dl
.text:004011B0         shr     al, 7
.text:004011B3         mov     bl, 1Bh
.text:004011B5         imul    bl
.text:004011B7         add     dl, dl
.text:004011B9         xor     al, dl
.text:004011BB         xor     al, [ebp+var_2]
.text:004011BE         mov     dl, [ecx-1]
.text:004011C1         xor     al, [ebp+var_1]
.text:004011C4         xor     dl, [ecx]
.text:004011C6         mov     [ecx-2], al
.text:004011C9         mov     al, dl
.text:004011CB         shr     al, 7
.text:004011CE         imul    bl
.text:004011D0         add     dl, dl
.text:004011D2         xor     al, dl
.text:004011D4         xor     al, [ecx-1]
.text:004011D7         mov     dl, [ebp+var_3]
.text:004011DA         xor     al, [ebp+var_1]
.text:004011DD         mov     [ecx-1], al
.text:004011E0         mov     al, dl
.text:004011E2         shr     al, 7
.text:004011E5         imul    bl
.text:004011E7         add     dl, dl
.text:004011E9         xor     al, dl
.text:004011EB         xor     al, [ecx]
.text:004011ED         mov     dl, [ecx+1]
.text:004011F0         xor     al, [ebp+var_1]
.text:004011F3         xor     dl, [ebp+var_2]
.text:004011F6         mov     [ecx], al
.text:004011F8         mov     al, dl
.text:004011FA         shr     al, 7
.text:004011FD         imul    bl
.text:004011FF         add     dl, dl
.text:00401201         xor     al, dl
.text:00401203         xor     al, [ecx+1]
.text:00401206         add     ecx, 4
.text:00401209         xor     al, [ebp+var_1]
.text:0040120C         dec     esi
.text:0040120D         mov     [ecx-3], al
.text:00401210         jnz     short loc_401194
.text:00401212         pop     esi
.text:00401213         pop     ebx
.text:00401214         leave
.text:00401215         retn
.text:00401215 aes_mix_columns endp
```

 Links 
  - [Rijndael MixColumns](https://en.wikipedia.org/wiki/Rijndael_MixColumns)
  - [How to solve MixColumns? (Answer)](https://crypto.stackexchange.com/a/2403)
